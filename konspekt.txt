Концепции Vue:
1. Virtual DOM.
    Перерисовка изменений дом дерева. Сравнивается оригинальное и виртуальное дерево. Если есть отличия (изменения) - 
    идет перерисовка. 
2. Компонентный подход:
    Компонент - переиспользуемый логически-завершенный кусок. Чаще всего корненвой компонент - app.vue. Компонент 
    подразделяется на другие и так далее. 
3. Реактивность:
    Проблема (если б не было вуе): есть счетчик лайков и кнопка для увеличения их кол-ва. На кнопке ивент листенер.
    При нажатии - увеличиваем счетчик и заносим его значение в текст. Т.е. данные и визуальное отображение никак не 
    связано: надо руками заносить новое значение. 
    Используя вью - мы имеем стэйт (Данные), где при нажатии меняется кол-во лайков и идет перерисовка. Упор идет 
    больше на работу с данными, чем с графическим отображением.  
    Вуе оборачивает модель в js proxy и делает "ловушки" на get и set. При изменении значения/срабатывании ловушки - 
    происходит ререндер. 

Создание проекта:
    1. Установить (если нет) nodejs (npm)
    2. npm install -g @vue/cli
    3. vue create project-name
    4. Если ошибка что нельзя запустить выполнение сценариев в системе - https://zawindows.ru/%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%BD%D0%B5%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7/
    5. Нужен инет для создания проекта.

Непосредственно:

В public/index.html в блок div с id app bd встраивается приложение.

npm run serve - запустить приложение на разработку.

npm run build - сбилдить на деплой проект.

В src исходники всего приложения.

createApp импоритруется из vue. В него передаем корневой компонент (App). mount('#app') -монтируем приложение 
в div#app.

Компоненты в vue - объекты, у которых есть предопределенные поля (data, methods...)
single file components - каждый компонент в отдельном файле.

В каждом файле компонента есть три составляющие (тега):
template, script, style.
template - типо верстка

script - здесь задаем логику компонента/создаем функции/объявляем данные. В этой секции мы экспортируем по дефолту
компонент. По факту script - и есть компонент. Все остальное - синтаксический сахар. Экспортируем объект с нужными
предопределенными полями (data, methods и т.д.).
В поле methods компонента можно объявлять функции для использования.
Чтоб получить доступ к данным из функции - обращаться this.var без data. (не this.data().var!)
Теперь есть функции, которые надо повесить на слушатель события:
Есть куча директив (в качестве параметра тега), начинающихся с v- . 
v-on  -слушатель события. Например для клика кнопки: v-on:click="methodName".
v-on можно заменить просто @
<button v-on:click="addLike">btn<button>   ===    <button @click="addLike">btn<button> 

Для хрома можно поставить vue devtools для дебага. На текущий момент бета-версия. Разрешить доступ ко всем сайтам 
и открывать файлы по ссылке. 

style -добавление стилей. 
Флаг scoped - стили будут распространяться только на текущий файл.

В style можно задавать стили для template как обычно css для html.

Добавим в script в data массив постов к примеру. (объектов с одинаковыми полями).
Для работы с массивами в template есть директива v-for="item in array"
Внутри блока с этой директивой будет доступен item. В цикле будет повторятся именно тот блок, на который наложили
директиву. 

Мы вводим что-то в инпуты - данные из них не заносятся в стейт. Надо организовать двустороннее связывание (как в реакт).
При изменении текста в инпутах - надо изменить данные стейта. Здесь это изи сделать. В инпутах байндим их значения к 
переменным стейта: v-bind:value="var".

Если через devtools поменять значение переменной инпута в стейте - текст изменится. Но если писать в инпут - в стейте текст не 
поменяется. Рассинхрон остается. Чтобы это исправить - надо повесить на input событие @input="titleInput", которое принимает event.
И из event'а надо достать текущее значение input'а и поместить в стейт.
Но можно не создавать отдельный метод обработчик. Во вуе есть ключевое слово $event, которое можно юзать в директиве.
Прям в ней: @input="title = $event.target.value"

Теперь просто по кнопке добавления поста - создаем новый объект поста по переменным из стейта и пушим его в общий массив.
Каждому элементу необходим для ключа(ниже) уникальный id. Можно взять текущую дату и время.
Чтобы форма не сабмитилась - надо на нее повесить @submit.prevent   -посты добавляются

Теперь чтоб очистить инпуты - надо просто очистить переменные в стейте.

Декомпозируем по компонентам. Разделим на компоненты форму и список постов.

В PostList.vue мы не запихиваем массив постов. Это переиспользуемый компонент, ему надо передавать список для отображения.
Параметры, передаваемые компоненту - пропсы

Style в PostList и PostForm можно сделать scoped 

Импортируем компоненты в script компоненты App.vue : import PostForm from "@/components/PostForm"
@ - элиас: указывает путь к папке src.
После импорта их надо зарегать: в стейте есть поле components.
components: {
    PostList, PostForm
},
Теперь мы можем их использовать в template в виде post-list или post-form

Прокидывание пропсов: (массив постов в пост лист)
В принимающем компоненте надо указать поле props, название ожидаемого поля, можно указать его тип, значение по дефолту и сделать его 
required:
props: {
    posts: {
        type: Array,
        required: true,
    },
},
Если required-пропс не передан - это варнинг в консоли.

В компоненте, который передает пропс - надо в компонент при помощи v-bind:var="var" передать значение: 
<post-list v-bind:posts="posts"
Кратко вместо v-bind можно просто написать :
<post-list :posts="posts" />

Пропсы менять нельзя! родитель их меняет, а дочерний только юзает.

Двухстороннее связывание с разными типами инпут: 
input, textarea : oninput , value
checkbox, radio btn : onchange , checked
списки : onchange , value

Вместо полей title и body создадим объект post с этими полями.
Чтоб каждый раз с двух сторон все не привязывать придумали директиву v-model для базовых типов инпутов.
v-model="post.title"
В vue3 можно использовать в компоненте несколько v-model

Теперь метод для создания объектов закинуть в PostForm. В нем в объект пост просто добавить поле id.
    Добавление поста в массив в родительском классе:
Надо в дочернем компоненте сгенерировать событие, параметром в которое передать новый пост. Родительский компонент подпишется на это
событие и, при возникновении, добавит у себя новый пост.
Событие генерится при помощи метода this.$emit('названиеСобытия', this.параметры, ...)
В дочернем:
methods: {
    createPost() {
        this.post.id = Date.now()
        this.$emit('create', this.post)
        this.post = { title: '', body: '' }
    }
}
В родительском подписываемся на событие в месте подключения компоненты:
<post-form @create="createPost" />
И описываем в родителе createPost, куда параметром придет новый post.

Вынесем отдельно PostItem. В данном случае непосредственно <post-item v-for="posts in post" :post="post" />
PostItem принимаем пропс post и отрисовует его.

Удаление поста: 
В PostList для каждого поста добавим кнопку удалить
Кнопки удалить стремные. Кнопка создать - красивая. Кнопка - некий ui-элемент. Сделаем его переиспользуемым.
В components создать папку UI и там компонент кнопки.
Если в компонент при подключении поместить что-либо внутрь (открыть-закрыть) - этот (текст) можно получить при помощи <slot />
уже в самой компоненте. Есть именнованные слоты. : <my-button>Create</my-button>  =>  <template><button><slot /></button></template>

Любые стили/директивы, которые накладываются на компонент при подключении - уйдут на его корневой тег.

MyButton и другие UI-компоненты будем юзать часто - каждый раз подключать их - не то.
В папке UI создадим index.js, из которого будем экспортировать по дефолту массив элементов. Подключаем нужные (mybutton)
и засовуем в массив. MyButton надо задать свойство name: 'my-button'

Импортируем в main.js компоненты из папки UI. Далее глобально их регистрируем в цикле:
const app = createApp(App)
components.forEach(component => {
    app.component(component.name, component)
})

app.component('имя компонента', сам компонент)
- глобально регистрируем компонент в app. Теперь его можно юзать везде.

Для двухстороннего связывания с помощью v-model можно явно указать value - v-model:title.
Если его нет - юзается по дефолту modelValue. Тоже самое с событием для инпутов - onUpdate:modelValue
Иначе - onUpdate:title. Таким образом можно юзать много v-model'ов в одном компоненте. Во vue2 было только value и onUpdate:value, 
и соответственно один v-model только.

Как это выглядит: если мы юзаем один дефолтный v-model (чаще всего):     <my-input v-model="post.title" placeholder="Title" />
То в MyInput надо принять в props modelValue (props: { modelValue: [String, Number], },), забиндить его в value инпута. 
На input повесть обработчик @input. В обработчике заэмитить событие update:modelValue, и передать туда event.target.value :
updateInput(event) { this.$emit('update:modelValue', event.target.value) }
Двухстороннее связывание - готово! Если мы явно задаем имя атрибута: v-model:value="post.title" - надо везде modelValue поменять на value.
Родитель по дефолту слушает событие update:modelValue и обновляет поле. 

Нельзя делать несколько v-model'ов с одинаковыми именами.

Когда выводим список в цикле - каждому элементу надо биндить уникальный ключ :key="id" ибо вуе строит виртуальное дом дерево и каждому
элементу будет дам виртуальный узел. Для работы вуе с этими узлами необходим уникальный ключ. Не рекомендуется юзать индекс элемента в 
массиве, ибо элемент можно удалить и они сдвинутся.

Удаление поста: 
При нажатии на кнопку удалить в postitem эмитим событие remove: this.$emit('remove', post)
Слушает его сверху PostList, который не может менять массив постов. Он должен передать его выше: 
<post-item @remove="$emit('remove', post)" .../>
Уже в App.vue обрабатываем событие remove у PostList. И удаляем элемент поста из массива по id:
this.posts = this.posts.filter(p => p.id !== post.id)

Услованя отрисовка:
<div v-if="posts.length > 0">Posts: </div>
<div v-else-if="condition"> .... </div>
<div v-else>End of conditions</div>

Если условие v-if/else не выполняется - элемент не заносится вообще в дом дерево. Иногда так не надо. Есть v-show="condition" 
Если не выполняется условие v-show - элемент делается просто display:none.
<div v-show="posts.length > 0">Posts: </div>
<div v-show="posts.length === 0"> .... </div>

Создадим MyDialog - диалоговое окно, в которое можно запихнуть что хочешь и засунем в него форму создания поста. 
При клике не на контентную часть диалога (на темный фон) - оно должно закрываться. Сейчас если нажать на контентную часть - 
оно все закроется, ибо всплытие события в жс. Чтобы исправить - есть stopPropagation. В vue - просто stop к событию:
@click.stop

v-model имеет модификаторы: v-model.trim=  v-model.number= v-model.lazy=
v-model.trim   -обрезает пробелы лишние по бокам значения.
v-model.number -кастит приходящее значение в число (по возможности)

Взаимодействие с сервером:
создадим async метод. На jsonplaceholder можно получать шаблонные значения. Там есть посты.
(написал свое апи)
Установим axios. ПО кнопке выгружаем посты и закидываем их в стейт вместо захардкоденых.

Теперь надо выгружать посты по загрузке компонента. В этом поможет ЖиЗненный ЦИкл компонента:
Жизненный цикл компонента заключает четыре этапа: создание, монтирование, обновление, удаление компонента. Этому всему соответствует
8 методов - хуков:
beforCreate, created, beforMount, mounted, beforUpdate, updated, beforUnmount, unmounted. 
-функции, которые вызываются в разные моменты существования компонента. Выгрузку с сервера обычно делают в mounted.

Посты загружаются практически моментально, надо добавить индикатор загрузки. Добавляем булл индикатор - перед выгрузкой ставим в тру, 
после в фолс.

Сортировка: создали MySelect.В него передаем массив параметров сортировки. Повесили событие. Теперь можно сортировать массив
постов. Тут нужные ВЫЧИСЛЯЕМЫЕ И НАБЛЮДАЕМЫЕ свойства:
Наблюдаемые - watch
Вычисляемые - computed

Наблюдаемое свойство - функция, которая вызывается когда наблюдаемая модель - изменена. Изменили значение счетчика - выполнилась.
Вычисляемые свойства - те же функции, но должны что-то возвращать (отсортированный массив)
Computed отличается от Watch тем, что если компьютед возвращает значение - оно запоминается, пока не изменится значение, от которого
зависит. Пример: фильтруем массив и возвращаем его: Watch будет вызываться при каждом ререндере, а компьютед вернет раз - и пока 
не добавим элемент в массив - она не переработает. (типо кеширование).

Обработчик должен быть того же имени, что и модель: 
watch: {
    selectedSort(newValue) { }
}
Принимает новое значение модели

Для отслеживания всех изменений тех же объектов нужно глубокое отслеживание:
watch: {
    post: {
        handler(newValue) {
            console.log(newValue)
        },
        deep: true,
    }
}
-отслеживаем ввод символов при создании поста (при каждом вводе отработает)

Сортировка при помощи watch:
watch: {
    selectedSort(newValue) {
      this.posts.sort((post1, post2) => {
        return post1[this.selectedSort]?.localeCompare(
          post2[this.selectedSort]
        );
      });
    },
  },

-selectedSort - как название модели. На ее изменение и сработает. И сортируем сам массив постов.

Сортировка при помощи computed:
computed: {
    sortedPosts() {
      return [...this.posts].sort((post1, post2) => {
        return post1[this.selectedSort]?.localeCompare(
          post2[this.selectedSort]
        );
      });
    },
  },
Здесь мы не меняем сам массив. Мы его расшариваем, потом сортируем и возвращаем. Использовать - просто передать в :posts="sortedPosts"
как переменную.

Во вью есть разные анимации. В т.ч. анимации списков. Все в доке.
Например если юзаем v-for - надо юзать компонет transition-group чтоб наложить анимацию.
(завернуть весь блок с циклом в транзишн груп)
Дать имя транзишн груп и юзать к нему стили из доки. 

Динамическое добавление класса тегу по условию:
<div :class="{
    'class-name': condition
}">
Также можно биндить inline-стили:
:style="{
    'background': 'green'
}"

Сделаем просматриваемое свойство watch на current_page - когда оно будет менятся - будем перевыбирать из БД
посты. 

Закомментим всю пагинацию и сделаем подгрузку ленты в ее конце:
Добавим метод догрузки постов. От обычного фетча он отличается тем, что в массив постов мы расшариваем 
старые посты и в конец добавляем новые:
        this.posts = [...this.posts, ...response.data.data];

Осталось только узнать когда юзер долистает:
Под списком постов создадим блок высотой ~30px и цветом (чтоб видно было). В реал проекте - его не должно 
быть видно. Intersection API в браузере - позволяет отследить, когда мы пересекли элемент.  
В mounted начнем следить за этим блоком:

const observer = new IntersectionObserver((entries, observer) => {
    /* Callback */
}, {
    rootMargin: '0px',
    threshold: 1.0
})

Далее при помощи observer.observe(дом-элемент)  -указать за каким элементом следить.
Чтоб получить доступ к дом-элементу использовать ref:
<div ref="название-рефа">...
Далее:
this.$refs.название-рефа    

observer.observe(this.$refs.observer)

По дефолту коллбэк срабатывает и когда мы пересекаем блок и уходим с него. entries - параметры 
данного события. Там есть IsIntersected - пересекли ли блок на данный момент. Проверим его в условии:
if (entries[0].isIntersecting && this.current_page < this.total_pages)
Тут и будем подгружать.
В подгрузке каждый раз current_page += 1

Роутинг:
Разные страницы. 
При создании приложения мы добавили router. Создадим папку router. В ней router.js
В нем создадим массив с объектами, в которых опишем путь к странице (path) и компонент (component).
Создадим папку pages, в ней Main.vue - главная страница

В router.js создадим router:
const router = createRouter({
    routes,  -наши роуты
    history: createWebHistory(process.env.BASE_URL)  -история роутинга (добавили при создании)
})

export default router

Зарегать роутер в приложении:
В main.js:
У экземпляра приложения (app) вызываем use:
app.use(router).mount..
-таким образом подключаются библиотеки, бутстрап и т.д. 
Перенесем все из App.vue в PostPage.vue (страница в pages). Оставим только глобальные стили и корневой
див app. App - по прежнему корневой компонент приложения. В него будут встраиваться все страницы. 
Надо в div.app добавить <router-view></router-view>  -в этот компонент будут встраиваться все страницы.

Ссылки:
    <router-link to="/link">LInk Name</router-link>
    to - обязательный пропс (адресс ссылки)
Эти линки как в react - не перезагружают страницы.

Создадим в UI навбар.

Чтоб по кнопкам переходить по ссылкам - надо добавить на @click. @click="$router.push('/posts')"
На любой элемент можно повесить @click="$router.push('link')" и переходить по ссылкам.

Это статические маршруты. Иногда нужно передавать параметры (страница поста):
В routes добавить объект с path="/posts/:id"
id - параметр маршрута. 
Получение параметров из роута: 
$route.params.id
$router - для роутинга
$route - для инфы

Доб. переиспользуемость: 
    Создадим свои директивы - вынесем функционал по отслеживанию 
пересечению объекта. Эту директиву сможем юзать на любом компоненте. 
Создадим папку directives, в ней VIntersection   -все директивы начинаются на V
Директива - объект, построенный особым образом. У каждой директивы жизненный цикл как у 
компонента, соответственно те же хуки. 
Пример: mounted - вызывается, когда монтируется родительский компонент, к которому
эта директива привязана. 
Импортируем в main.js и регаем для app:   app.directive('название', директива)
Теперь можем везде юзать 
Повесим на наш блок observer эту директиву. Реф можно убрать - mounted как раз принял
параметром тот дом элемент, который и нужен (напрямую можем взаимодействовать).

Также mounted принимает объект (binding)

При использовании директивы можем передать что-то внутрь:
    v-intersection="{name: 'Nikita'}"
Объект binding содержит поле value с переданными параметрами.
Можно передать функцию в директиву. 
Вот будем передавать функцию, которая будет нашим коллбэком при пересечении.
Перекинем из mounted Posts все в директиву для отслеживания пересечения. Заменим $refs.observer
На принимаемый элемент. 
Проверять корректность страниц теперь в loadMorePosts.
Создадим еще директив. Их может быть много. Подгружать все вручную - не оч
Сделаем как с UI. Создадим index.js в directives 
- импортируем в него директивы, и экспортируем массив с ними.
В main импортируем все директивы из directives, и форичем регаем все. 
Только имени нет у них. - добавим поле name просто в объект директивы.
в итоге в main :    
                    directives.forEach(directive => {
                        app.directive(directive.name, directive)  
                    })

К примеру создадим директиву VFocus, в mounted будем элементу делать фокус: el.focus()
Наложим эту директиву на первый инпут диалогового окна создания поста. Теперь при открытии
формы - первый инпут сразу в фокусе. Можно также добавить на инпут для поиска

mixins (миксины, примеси):
Mixins - объект с теми же свойствами компонента, от которого можно "унаследовать" компонент.
Если у компонентов есть общие черты - их можно вынести в миксины: у диалога и у селекта кастомного
есть видимость-невидимость, есть функция, которая это значение меняет. 

Создаем папку mixins - в ней toggleMixin.js и экспортируем объект с data(), methods, props и т.д..
Закинем в toggleMixin в props принимаемое show и в methods hide. Теперь это можно удалить из 
MyDialog, и заюзать миксин (просто в объекте поле mixins: [массив миксином]):
name: 'my-dialog',
mixins: [toggleMixin],

Если добавить два одинаковых хука - сначала отработает из миксина, потом из диалога.
Миксин похож на trait.

Управление состоянием приложения: чаще всего с вью юзают vuex - библиотека для управления состоянием
Для 3 версии vue - 4 vuex. Без системы управления стейтом - данные летят по цепочке (пропсам) от
родителя - детям и обратно (по дереву). Иногда данные очень неудобно перекидывать в самый низ через 
кучу компонент. Плюс хорошо бы отделить данные от представлений. Данные, 
и функции, которые их меняют выносятся в store (vuex),
который их раскидывает по компонентам глобально. 

Продублируем posts page в PostsPageStore - тут будем юзать store. Добавим его отдельно в роутинг. 

Создадим папку store, в ней index.js, в нем импортируем {creteStore} from 'vuex'.
Из него экспортируем результат createStore, который в себя принимает объект с полями-объектами:
state (сами данные, объявлять как функцию, которая возвращает объект), 
getters, mutations (аксессоры), actions (события), модули.
В большом приложении стор превратился бы в мусорку. Для этого есть модули, которые 
подразделяют стор, а потом сливаются в один большой. В actions не рекомендуется менять данные
из стейта. Лучше это делать через mutations.

Подключение стора: в main.js импортируем и use(store)

В debugtools можно посмотреть также маршруты и состояние стора.
Создадим в стейте тестовую переменную likes. Сделаем счетчик как в начале.

Для работы со стором есть специальный объект $store :
$store.state.likes
-глобальное хранилище. Доступно везде. 

Геттеры - подобны computed функциям внутри компонентов. Должны что-то возвращать.
Геттеры принимают state в параметр. Менять ничего нельзя! Только возвращать. 
Обращаться к геттеру как к переменной: $store.getters.doubleLikes

Mutations тоже принимают state. В них можно менять значение. Вызывать их:
$store.commit("название mutations'a")

Стор - тоже реактивный. Стейт меняется - данные перерисовуются!

Писать store, getters, mutations, actions в createStore объекте - неперспективно.
Удалим все, оставим только модули. В папке store создадим файл postModule.js. Из него 
export const postModule = {
    state: () => ({

    }),
    getters: {}, mutations: {}, actions: {},
}

Перенесем все данные из PostPage в state. Удалим dialog visible
Для каждого поля создадим мутацию, которая позволит его установить:
setPosts(state, posts) {
    state.posts = posts 
}
в мутациях просто заносим данные в стейт. Их будут вызывать экшины. 
Для опций сортировки и лимита мутаций делать не надо - они не будут меняться.

Перенесем computed свойства в геттеры стора. У нас геттер вызывает другой геттер - надо 
принять вторым параметром getters и вызывать оттуда. Обращения к this заменяем на state.

fetchPosts и loadMorePosts - экшины. Они принимают объект контекст.
Объект контекст содержит: state(сам стейт), rootState, commit(для вызова мутаций), 
dispatch(для вызова других экшинов), getters(геттеры), rootGetters  достаем что надо:
async fetchPosts({state, commit})
this.isPostLoading = true  =>  commit('setPostLoading', true)
Поменяли все на state, commit, getters etc..
Теперь в index.js зарегаем модуль: 
import {postModule} from '@/store/postModule'
modules: {
    posts: postModule
}

Теперь в компонентах: $store.state.posts.limit  

При разрастании приложения в модулях могут быть методы с одинаковым именем. Чтоб избежать 
ошибки надо в модуле добавить флаг 
        namespaced: true,

Теперь обращаться к мутациям:    $store.commit('posts/setPostLoading', true) etc.

Каждый раз так вызывать мутации, гетеры, экшини и т.д. - сильно нагроможденно.
Импортируем в скрипт:   import {mapState, mapGetters, mapActions, mapMutations} from 'vuex'
-эти функции позволяют развернуть в поле methods actions и mutations, 
а в поле computed state и getters:

computed: {
    ...mapState({
      postLoading: (state) => state.posts.isPostLoading,
    }),
    ...mapGetters({
      sortedAndFiltered: 'posts/sortedAndFilteredPosts',
    }),
  },

methods: {
    ...mapMutations({
        setSelectedSort: "posts/setSelectedSort",
    }),
    ...mapActions({
      fetchPosts: 'posts/fetchPosts',
      loadPosts: 'posts/loadMorePosts',
    }),  

-таким образом мы убираем приставку и можем поменять название. 
Мы не можем юзать v-model. Ибо оно генерирует событие update для обновления modelValue,
а значения в стейте могут менять только мутации. Мапим мутации и заменяем:

 <my-input v-focus v-model="searchQuery" placeholder="Search..." />

на

 <my-input
      v-focus
      :model-value="searchQuery"  // переменная стейта
      @update:model-value="setSearchQuery"  // на ее обновление вызываем мутатор
      placeholder="Search..."
    />


COMPOSITION API  
нововведение в вью 3

Скопируем page Posts еще раз и реализуем все при помощи composition api:
Зарегает для него роут тоже.

В компоненте есть метод setup, который принимает props.
Все, что возвращаем из этого метода - доступно в компоненте.
Когда setup отработал - компонент еще не создан. Поэтому обращаться можно только к props и context (doc)

Чтобы сохранять реактивность для переменных - создаем при помощи ref (import ref from 'vue')
const likes = ref(default_value)
ref будет их оборачивать в объект. (в жс примитивы сравниваются по значению, а объекты по ссылке).
Доступ к значению по value:    likes.value

Создадим папку hooks. 
В ней будем создавать хуки:    usePosts   -хук для всей работы с постами.
Импортируем в компоненту {usePosts} from '@/hooks/usePosts'
В нем будем экспортировать функцию (хук) :    export function usePosts() {}
В хуках тоже есть методы жизненного цикла:  onMounted, onCreated etc...
Создаем с помощью ref'ов переменные постс, тотал пейджес и т.д., конст асинх функцию
fetching.  Потом вместе с ref подключим onMounted from "vue". 
В onMounted передадим fetching (один раз вызовем).
В конце в return возвращаем посты, страницы и статус загрузки, которые сможем вытащить в setup:
    const { posts, totalPages, isPostsLoading } = usePosts(limit)
Еще два хука:  useSortedPosts и useSortedAndFilteredPosts
Sorted принимает посты из результатов первого хука и сортирует. Второй принимает сортированые посты 
и фильтрует их. 
    const { sortedPosts, selectedSort } = useSorted(posts)
    const { sortedAndFilteredPosts, searchQuery } = useSortedAndFiltered(sortedPosts)

Из useSorted возвращаем не просто соритрованные посты, а computed свойство (import {computed} from "vue"):
    const sortedPosts = computed(() => {

Можно юзать vuex вместе с хуками. Компосишн - локальный стейт, vuex - глобальный.
При выполнении setup компонента еще не загружена - нельзя получить доступ к data(), methods, etc..

Мы из setup не можем доступиться к this, поэтому юзаем useRoute и useRouter (import from "vue-router")
const route = useRoute()  -те же параметры, что и $route.

Юзать vuex - глобальное хранилище для удобного доступа. actions инициируют mutations - 
потому, что мутации - синхронные, а actions - асинхронные. 

    ВЛАДИЛЕН ЛЕССОН:
Подключим vue как cdn 
Сам по себе Vue - просто объект
Вначале вызовем метод объекта Vue createApp, в который передается объект App.
В него передается настройка. В объект App можно передавать разные поля и методы:
data() возвращает объект, где ключ - название переменной, значение - ее начальное значение
Передадим с помощью интерполяции в index.html counter. - не сработает. Надо сказать вуе, в 
какой области он будет использован. Зададим для корневого div'a id app. И делаем mount('#app')

В интерполяцию можно выводить все из js, что может быть приведено к строке: объекты и 
массивы будут JSON.stringify. В интерполяции можно мат операции, условия и т.д.

undefined и null - будет пустым
Поля в data - модели

